using ITensors
using ITensorMPS
using Plots
using LinearAlgebra #line 19 set nsweeps #line 107 to modify chain-length

# Construct the Heisenberg Hamiltonian as an MPO
function heisenberg_mpo(N; J=1.0, S="S=1/2")
    sites = siteinds(S, N)
    os = OpSum()
    for i in 1:N-1
        os += 0.5*J, "S+", i, "S-", i+1
        os += 0.5*J, "S-", i, "S+", i+1
        os += J, "Sz", i, "Sz", i+1
    end
    return MPO(os, sites), sites
end

# FIXED: Proper excited state DMRG calculation
function calculate_gap_dmrg_fixed(L; J=1.0, maxdim=200, nsweeps=5)
    println("Calculating gap for L=$L using FIXED DMRG method...")
    H, sites = heisenberg_mpo(L; J=J)
    
    # Set up sweeps
    sweeps = Sweeps(nsweeps)
    setmaxdim!(sweeps, maxdim)
    setcutoff!(sweeps, 1e-10)
    setnoise!(sweeps, 1e-10)  # Add noise for better convergence
    
    # FIX 1: Find ground state without Sz constraint
    println("Finding ground state...")
    psi0 = randomMPS(sites, linkdims=10)
    E0, psi0 = dmrg(H, psi0, sweeps; outputlevel=0)
    println("Ground state energy: $E0")
    
    # FIX 2: Find first excited state orthogonal to ground state
    println("Finding first excited state...")
    psi1 = randomMPS(sites, linkdims=10)
    
    # Use the proper excited state DMRG method
    # This finds the lowest energy state orthogonal to psi0
    E1, psi1 = dmrg(H, [psi0], psi1, sweeps; outputlevel=0, weight=20.0)
    
    # Verify orthogonality
    overlap = abs(inner(psi0, psi1))
    println("First excited state energy: $E1")
    println("Overlap between ground and excited state: $overlap")
    
    # FIX 3: More robust excited state search if needed
    if overlap > 0.1  # States are not sufficiently orthogonal
        println("States not orthogonal enough, trying alternative method...")
        
        # Try different initial states for excited state
        best_E1 = Inf
        best_psi1 = psi1
        
        for trial in 1:3
            println("  Trial $trial...")
            psi_trial = randomMPS(sites, linkdims=10)
            
            # Use different random seed by applying random gates
            for i in 1:min(5, L-1)
                idx = rand(1:L-1)
                gate = randomITensor(sites[idx], sites[idx+1], sites[idx]', sites[idx+1]')
                psi_trial = apply(gate, psi_trial; cutoff=1e-10)
                normalize!(psi_trial)
            end
            
            E_trial, psi_trial = dmrg(H, [psi0], psi_trial, sweeps; outputlevel=0, weight=20.0)
            overlap_trial = abs(inner(psi0, psi_trial))
            
            println("    Trial $trial: E = $E_trial, overlap = $overlap_trial")
            
            if overlap_trial < 0.1 && E_trial < best_E1
                best_E1 = E_trial
                best_psi1 = psi_trial
            end
        end
        
        if best_E1 < Inf
            E1 = best_E1
            psi1 = best_psi1
            println("Best excited state energy: $E1")
        else
            println("Warning: Could not find good excited state")
            return 0.0
        end
    end
    
    gap = E1 - E0
    println("Energy gap: $gap")
    
    # FIX 4: Sanity check - gap should be positive
    if gap < 0
        println("Warning: Negative gap detected, this suggests numerical issues")
        return 0.0
    end
    
    return gap
end

# Main plotting function using the fixed method
function plot_gap_dmrg_fixed()
    # CHANGE THIS LINE TO EXTEND SYSTEM SIZES:
    # Current: Ls = 4:2:12 means systems of size 4, 6, 8, 10, 12
    # For larger systems: Ls = 4:2:20 or Ls = 6:2:16, etc.
    # WARNING: Larger systems take much longer to compute!
    Ls = 4:2:20  # ← MODIFY THIS LINE FOR DIFFERENT SYSTEM SIZES
    gaps = Float64[]
    
    for L in Ls
        println("\n--- Processing L = $L ---")
        gap = calculate_gap_dmrg_robust(L; maxdim=200, nsweeps=30)
        push!(gaps, gap)
    end
    
    # Create the plot
    plt = plot(Ls, gaps, marker=:o, xlabel="System Size L", ylabel="Energy Gap Δ",
        title="Energy Gap vs System Size (Fixed DMRG Method)", legend=false, 
        linewidth=2, markersize=6)
    
    # Add horizontal line at y=0 for reference
    hline!([0.0], linestyle=:dash, color=:red, alpha=0.5, label="Zero gap")
    
    # Add 1/L scaling reference line for comparison
    if length(gaps) > 1 && all(g -> g > 0, gaps)
        # Fit to 1/L scaling
        inv_L = 1.0 ./ Ls
        # Simple linear fit: gap ≈ a/L
        a_fit = sum(gaps .* inv_L) / sum(inv_L .* inv_L)
        fitted_gaps = a_fit ./ Ls
        
        plot!(Ls, fitted_gaps, linestyle=:dash, color=:green, alpha=0.7, 
              label="1/L scaling fit")
    end
    
    display(plt)
    return plt, gaps
end

# Execute the fixed version
println("Running fixed DMRG energy gap calculation...")
plt, gaps = plot_gap_dmrg_fixed()
